/**
 * 经验之谈：
 * 1. 遇到数组中有加减的操作符，一定要判断是否越界。
 * 2. 遇到是大于还是大于等于拿捏不定时，一定要测试边界条件。
 * 3. 递归类的题目，如二叉树，回溯，使用全部变量会大大简化算法复杂度。
 * 4. 二叉树题目遍历时，基本都需要定义void dfs(node)方法。
 * 5. 只有排列才需要借助selected数组，而组合和子集不需要借助selected数组。
 * 6. 遇到未排序的数组，当需要用到连续子数组的特性而不能排序时，单调栈就派上用场了。
 * 6.1 弹出时判断条件为 stack.peek() < arr[i]，则为栈为递减，因为当stack.peek() >= arr[i]时可以直接放入，所以顶部越来越小，因此当前单调栈递减。反之为递增。
 * 6.2 弹出时有三个属性值得关注：1.谁弹出了我（当前元素i），2.我是谁（stack.pop()）3.我弹出后当前栈顶是谁（stack.peek()，stack可能此时为空，为空的默认值为-1）
 * 7. 当两数只差正好为2的幂次方时，可以通过异或实现加减。如字母大小写互相转化，由于'a' - 'A' = 32，所以可以通过异或32实现大小写转化。
 */
package me.thomas.knowledge.algorithm.leetcode;