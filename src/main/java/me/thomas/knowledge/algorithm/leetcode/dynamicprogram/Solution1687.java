package me.thomas.knowledge.algorithm.leetcode.dynamicprogram;

/**
 * 1687. 从仓库到码头运输箱子
 * 你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 箱子数目的限制 和 总重量的限制 。
 * <p>
 * 给你一个箱子数组 boxes 和三个整数 portsCount, maxBoxes 和 maxWeight ，其中 boxes[i] = [portsi, weighti] 。
 * <p>
 * portsi 表示第 i 个箱子需要送达的码头， weightsi 是第 i 个箱子的重量。
 * portsCount 是码头的数目。
 * maxBoxes 和 maxWeight 分别是卡车每趟运输箱子数目和重量的限制。
 * 箱子需要按照 数组顺序 运输，同时每次运输需要遵循以下步骤：
 * <p>
 * 卡车从 boxes 队列中按顺序取出若干个箱子，但不能违反 maxBoxes 和 maxWeight 限制。
 * 对于在卡车上的箱子，我们需要 按顺序 处理它们，卡车会通过 一趟行程 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 额外行程 ，箱子也会立马被卸货。
 * 卡车上所有箱子都被卸货后，卡车需要 一趟行程 回到仓库，从箱子队列里再取出一些箱子。
 * 卡车在将所有箱子运输并卸货后，最后必须回到仓库。
 * <p>
 * 请你返回将所有箱子送到相应码头的 最少行程 次数。
 *
 * @author xinsheng2.zhao
 * @version Id: Solution1687.java, v 0.1 2022/12/6 23:30 xinsheng2.zhao Exp $
 */
public class Solution1687 {

    /**
     * 思路：前缀和 + 动态数组 + 二分法
     */
    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {
        int n = boxes.length;
        int[] prefixSum = new int[n + 1];
        prefixSum[0] = 0;
        for (int i = 1; i <= n; i++) {
            prefixSum[i] = prefixSum[i - 1] + boxes[i - 1][1];
        }

        int[] prefixContinue = new int[n + 1];
        prefixContinue[0] = 0;
        prefixContinue[1] = 1;
        for (int i = 2; i <= n; i++) {
            prefixContinue[i] = prefixContinue[i - 1] + (boxes[i - 2][0] == boxes[i - 1][0] ? 0 : 1);
        }

        int[] dp = new int[n + 1]; // 定义：将[0, i]区间的箱子运送到码头最低需要dp[i]次行程。
        dp[1] = 2; /* base case: 送第一个箱子需要2趟行程：从仓库运送箱子到码头x，再回到仓库 */
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + 2; // 最差情况是单独拉最后一个箱子。
            // 回头查找从哪里开始一起运送比较省行程
            int from = leftBound(prefixSum, Math.max(i - maxBoxes, 1), i, maxWeight); /* i是从1开始的 */
            for (int j = from; j < i; j++) {
                // 中间有连续码头相同的箱子算作一次行程
                int delivers = 2 + (prefixContinue[i] - prefixContinue[j]); // 一起运送的箱子至少有去和回两个行程。
                dp[i] = Math.min(dp[i], dp[j - 1] + delivers);
            }
        }
        return dp[n];
    }

    int leftBound(int[] prefix, int from, int to, int target) {
        int low = from, high = to;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (prefix[to] - prefix[mid - 1] <= target) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }

    public static void main(String[] args) {
        Solution1687 solution1687 = new Solution1687();
        //System.out.println(solution1687.boxDelivering(new int[][] { { 1, 4 }, { 1, 2 }, { 2, 1 }, { 2, 1 }, { 3, 2 }, { 3, 4 } }, 3, 6, 7));
        //System.out.println(solution1687.boxDelivering(new int[][] { { 2, 4 }, { 2, 5 }, { 3, 1 }, { 3, 2 }, { 3, 7 }, { 3, 1 }, { 4, 4 }, { 1, 3 }, { 5, 2 } }, 5, 5, 7));
        System.out.println(solution1687.boxDelivering(
                new int[][] { { 61, 4840 }, { 66, 16490 }, { 54, 15479 }, { 48, 5555 }, { 25, 3120 }, { 47, 1010 }, { 30, 3236 }, { 7, 9270 }, { 55, 14900 }, { 48, 11603 },
                              { 104, 12299 }, { 3, 8266 }, { 3, 1440 }, { 15, 5659 }, { 72, 13285 }, { 32, 10642 }, { 26, 5780 }, { 88, 15220 }, { 16, 3808 }, { 27, 11203 },
                              { 41, 7645 }, { 79, 10232 }, { 73, 403 }, { 86, 11181 }, { 25, 5789 }, { 12, 15415 }, { 59, 2075 }, { 60, 11185 }, { 39, 2213 }, { 103, 12049 },
                              { 99, 9585 }, { 40, 16489 }, { 71, 3282 }, { 47, 10552 }, { 10, 11910 }, { 86, 7606 }, { 6, 654 }, { 30, 14945 }, { 14, 3796 }, { 22, 5430 },
                              { 10, 13458 }, { 74, 2169 }, { 81, 10010 }, { 92, 6330 }, { 104, 778 }, { 100, 3311 }, { 98, 5975 }, { 56, 15520 }, { 13, 11700 }, { 19, 6890 },
                              { 99, 2910 }, { 62, 1393 }, { 48, 5638 }, { 9, 10967 }, { 38, 945 }, { 23, 14549 }, { 43, 4081 }, { 42, 4540 }, { 82, 5832 }, { 69, 5072 },
                              { 19, 15047 }, { 85, 4330 }, { 57, 3549 }, { 32, 6955 }, { 46, 15456 }, { 80, 1358 }, { 58, 25 }, { 95, 9401 }, { 10, 15268 }, { 32, 12504 },
                              { 10, 4724 }, { 83, 4816 }, { 45, 2084 }, { 33, 7725 }, { 32, 3637 }, { 103, 7506 }, { 103, 51 }, { 69, 6945 }, { 42, 4017 }, { 66, 5596 },
                              { 83, 305 }, { 56, 10441 }, { 70, 3892 }, { 78, 2290 }, { 50, 6269 }, { 23, 14932 }, { 17, 11895 }, { 43, 3679 }, { 39, 3086 }, { 43, 16224 },
                              { 12, 13993 }, { 92, 14876 }, { 6, 1219 }, { 65, 8544 }, { 25, 658 }, { 79, 5722 }, { 19, 14103 }, { 80, 16496 }, { 56, 8778 }, { 44, 4481 },
                              { 36, 14814 }, { 77, 2370 }, { 2, 7206 }, { 100, 1700 }, { 24, 1636 }, { 36, 8805 }, { 46, 7068 }, { 7, 13167 }, { 45, 8375 }, { 63, 9633 },
                              { 83, 8546 }, { 13, 15183 }, { 73, 14140 }, { 12, 1395 }, { 101, 2581 }, { 2, 5718 }, { 16, 2783 }, { 34, 9200 }, { 42, 10048 }, { 74, 1353 },
                              { 74, 2485 }, { 33, 4091 }, { 21, 9159 }, { 79, 10195 }, { 1, 9576 }, { 63, 11647 }, { 104, 5794 }, { 103, 2786 }, { 46, 121 }, { 23, 5173 },
                              { 35, 7066 }, { 13, 12041 }, { 51, 9573 }, { 56, 2992 }, { 81, 4133 }, { 58, 9161 }, { 27, 9496 }, { 86, 4972 }, { 33, 11241 }, { 88, 11329 },
                              { 69, 3844 }, { 47, 1487 }, { 94, 15931 }, { 48, 11569 }, { 15, 2003 }, { 26, 11104 }, { 33, 6961 }, { 6, 15453 }, { 2, 11193 }, { 14, 3942 },
                              { 94, 10791 }, { 71, 1871 }, { 98, 13280 }, { 73, 8641 }, { 21, 9413 }, { 22, 12239 }, { 38, 14552 }, { 92, 14876 }, { 43, 4579 }, { 21, 12583 },
                              { 67, 13959 }, { 71, 9938 } }, 106, 74, 16517));
    }
}
